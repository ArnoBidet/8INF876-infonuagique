\section{Implémentation et Tests}

\subsection{Introduction}
Ce chapitre présente les outils technologiques utilisés pour la preuve de concept (PoC) et détaille l'implémentation de l'algorithme critique de délimitation de zone.

\subsection{Outils d'implémentation}
Pour réaliser ce prototype décentralisé, nous avons utilisé :
\begin{itemize}
    \item \textbf{Langage :} Python 3.11 (backend et logique algorithmique distribuée).
    \item \textbf{Communication :} MQTT avec Eclipse Mosquitto (communication inter-drones).
    \item \textbf{Web Framework :} Flask (pour servir l'API de l'état global du système).
    \item \textbf{Visualisation :} Leaflet.js (cartographie) et Chart.js (graphiques temps réel).
    \item \textbf{Conteneurisation :} Docker et Docker Compose pour orchestrer les services autonomes.
    \item \textbf{Threading :} Python threading pour la gestion concurrente (publication/écoute MQTT).
\end{itemize}

\subsection{Approche prise pour l'implémentation}

\subsubsection{Architecture décentralisée avec MQTT}
Le système implémente une architecture peer-to-peer complète où chaque drone :
\begin{itemize}
    \item Publie sa position toutes les 3 secondes sur le topic \texttt{drones/positions}
    \item Écoute les positions des autres drones pour maintenir une vue locale
    \item Participe à l'élection automatique du leader (ID minimum)
    \item Nettoie automatiquement les drones inactifs (timeout de 15 secondes)
\end{itemize}

\subsubsection{Calcul distribué de l'Enveloppe Convexe}
Le cœur du système repose sur l'algorithme de la \textit{Chaîne Monotone} (Monotone Chain), mais exécuté uniquement par le drone leader pour optimiser les performances. C'est cette enveloppe qui définit la "zone sûre" distribuée à l'instant $t$.

Voici l'extrait du code implémenté dans \texttt{drone\_subscriber.py} :

\begin{lstlisting}[language=Python, caption=Leadership et Calcul Distribué]
def is_leader():
    """Determine if this drone should act as leader"""
    with drone_lock:
        all_drone_ids = [DRONE_ID] + list(other_drones.keys())
        return DRONE_ID == min(all_drone_ids)

def compute_convex_hull(points):
    """Compute convex hull using monotonic chain algorithm"""
    if len(points) <= 1:
        return points
    
    def cross(o, a, b):
        return (a[0]-o[0]) * (b[1]-o[1]) - (a[1]-o[1]) * (b[0]-o[0])
    
    pts = sorted([(p['lat'], p['lng']) for p in points])
    
    # Construction de la partie inferieure
    lower = []
    for p in pts:
        while len(lower) >= 2 and cross(lower[-2], lower[-1], p) <= 0:
            lower.pop()
        lower.append(p)
    
    # Construction de la partie superieure
    upper = []
    for p in reversed(pts):
        while len(upper) >= 2 and cross(upper[-2], upper[-1], p) <= 0:
            upper.pop()
        upper.append(p)
    
    hull = lower[:-1] + upper[:-1]
    return [{'lat': p[0], 'lng': p[1]} for p in hull]
\end{lstlisting}

\subsubsection{Configuration décentralisée avec Docker}
Chaque drone est un service Docker indépendant avec ses propres paramètres :

\begin{lstlisting}[language=yaml, caption=Configuration Docker des Drones Autonomes]
drone1:
  environment:
    - DRONE_ID=1
    - DRONE_START_LAT=46.9131
    - DRONE_START_LNG=-71.2085
    - DRONE_RADIUS=800
    - MQTT_BROKER=mqtt-broker
  command: ["python", "-u", "drone_subscriber.py"]

drone2:
  environment:
    - DRONE_ID=2
    - DRONE_START_LAT=46.9131
    - DRONE_START_LNG=-71.2045
    - DRONE_RADIUS=1000
\end{lstlisting}

\subsubsection{Simulation de mouvement décentralisée}
Chaque drone implémente sa propre logique de mouvement avec patrouille circulaire autonome. La fonction \texttt{generate\_single\_drone} calcule la position individuelle, combinant :
\begin{itemize}
    \item Mouvement global vers l'ouest (formation d'essaim)
    \item Patrouille circulaire autour de la position de départ
    \item Publication périodique pour coordination avec les pairs
\end{itemize}

\subsection{Discussion des résultats}
L'application web permet de visualiser en temps réel le système décentralisé :
\begin{enumerate}
    \item Les positions individuelles des drones autonomes (marqueurs bleus).
    \item La zone de sécurité calculée par le drone leader (polygone orange).
    \item L'identification du drone leader actuel dans les logs.
    \item La résilience du système lors de pannes simulées.
    \item Le nombre d'entités "In-Zone" vs "Out-Zone" via des graphiques.
\end{enumerate}

Les tests ont validé plusieurs aspects critiques :
\begin{itemize}
    \item \textbf{Élection automatique :} Le drone avec l'ID minimum devient leader automatiquement
    \item \textbf{Tolérance aux pannes :} La suppression d'un drone (y compris le leader) déclenche une réorganisation automatique
    \item \textbf{Performance :} Seul le leader calcule l'enveloppe convexe, optimisant les ressources
    \item \textbf{Synchronisation :} Les positions se synchronisent en moins de 3 secondes entre tous les drones
\end{itemize}

\subsection{Conclusion}
L'implémentation démontre la faisabilité d'un système de géofencing complètement décentralisé avec :
\begin{itemize}
    \item \textbf{Zéro point de défaillance unique :} Aucun service centralisé critique
    \item \textbf{Auto-organisation complète :} Élection automatique et ré-élection des leaders  
    \item \textbf{Scalabilité horizontale :} Ajout/suppression dynamique de drones
    \item \textbf{Performance optimisée :} Calculs distribués uniquement quand nécessaire
\end{itemize}

L'architecture est suffisamment légère pour être déployée sur des microcontrôleurs embarqués tout en maintenant une résilience maximale du système distribué.
